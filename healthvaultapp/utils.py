import logging

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.urlresolvers import reverse

from healthvaultlib import exceptions as hv_exceptions
from healthvaultlib.healthvault import HealthVaultConn

from . import defaults
from .models import HealthVaultUser


logger = logging.getLogger(__name__)


# Used by HealthVault to authenticate this application.
sharedsec = None
auth_token = None


def create_connection(wctoken=None, record_id=None, **kwargs):
    """Shortcut to create a HealthVaultConn instance.

    HealthVault configuration parameters can be passed in but default to those
    defined in the project settings. The `wctoken` authenticates this
    connection to retrieve ata for a specific user. If the `record_id` of the
    corresponding user is known, it can be passed in to save a network call to
    look up the `record_id`.

    The `sharedsec` and `auth_token` generated by a HealthVaultConn are cached
    to be used again in future connections.

    If HealthVaultConn raises a ValueError, this is caught and an
    :py:exc:`django.core.exceptions.ImproperlyConfigured` exception is thrown
    in its place. Other exceptions thrown by HealthVaultConn are propagated.

    :raises: :py:exc:`django.core.exceptions.ImproperlyConfigured` if settings
        are unspecified, null/blank, or incorrect.
    """
    global sharedsec, auth_token

    # Default configuration parameters from the settings.
    config = {
        'app_id': get_setting('HEALTHVAULT_APP_ID'),
        'app_thumbprint': get_setting('HEALTHVAULT_THUMBPRINT'),
        'public_key': get_setting('HEALTHVAULT_PUBLIC_KEY'),
        'private_key': get_setting('HEALTHVAULT_PRIVATE_KEY'),
        'server': get_setting('HEALTHVAULT_SERVER'),
        'shell_server': get_setting('HEALTHVAULT_SHELL_SERVER'),
    }
    config.update(kwargs)

    # Require that configuration parameters be non-null.
    for key, value in config.items():
        if not value:
            msg = '{0} cannot be null, and must be explicitly ' \
                    'specified or set in your Django settings.'.format(key)
            raise ImproperlyConfigured(msg)

    # Since sharedsec and auth_token go together, reset them if both aren't
    # present.
    if sharedsec and auth_token:
        config['sharedsec'] = sharedsec
        config['auth_token'] = auth_token
    else:
        shared_secret = None
        auth_token = None

    try:
        conn = HealthVaultConn(wctoken=wctoken, record_id=record_id, **config)
    except ValueError as e:
        logger.error(e)
        msg = 'Public and private keys should be long values: ' \
              '{0}'.format(e.message)
        raise ImproperlyConfigured(msg)
    except hv_exceptions.HealthVaultException as e:
        # We must reset sharedsec and auth_token in the case that the ones we
        # have are expired or invalid and can't be reused.
        sharedsec = None
        auth_token = None
        logger.error(e)
        raise e

    # Save the sharedsec and auth_token for future use.
    sharedsec = conn.sharedsec
    auth_token = conn.auth_token

    return conn


def get_setting(name, use_defaults=True):
    """Retrieves the specified setting from the project settings file.

    If the setting is not found and ``use_defaults`` is ``True``, then the
    default value specified in ``defaults.py`` is used.

    :raises: :py:exc:`django.core.exceptions.ImproperlyConfigured` if the
        setting is not found.
    """
    if hasattr(settings, name):
        return getattr(settings, name)
    elif use_defaults:
        if hasattr(defaults, name):
            return getattr(defaults, name)
    msg = '{0} must be specified in your settings'.format(name)
    raise ImproperlyConfigured(msg)


def is_integrated(user):
    """
    Returns ``True`` if we have HealthVault authentication data for the
    user. This does not require that the authentication data is valid.

    :param user: A Django user.
    """
    if user and user.is_authenticated() and user.is_active:
        return HealthVaultUser.objects.filter(user=user).exists()
    return False


def get_callback_url(request):
    """
    Returns the callback url that HealthVault should use after the user makes
    changes to this application's permissions.

    If this project is running in production, HealthVault will always callback
    to the URL defined in the application's ActionURL. Since an error may
    occur if an alternative callback is provided, we return None.
    """
    if get_setting('HEALTHVAULT_IN_DEVELOPMENT'):
        return request.build_absolute_uri(reverse('healthvault-complete'))
    return None
